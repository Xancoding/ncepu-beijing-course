[栈](https://git.acwing.com/ZagY/learn-data-structures/-/tree/main/Stack)
[队列](https://git.acwing.com/ZagY/learn-data-structures/-/tree/main/Queue)
# 栈的应用
## 迷宫求解
## 括号匹配
## 进制转换
## 表达式求值
## 将算数表达式转换为后缀表达式
- 运算符  #    (    +    -    *    /
- 优先数  -1   0    1   1  2   2
1. 设立暂存运算符的栈
2. 设表达式的结束符为 `# ` ，设运算符栈的栈底为 `#`
3. 若当前字符是操作数，则直接发送给后缀式
4. 若当前运算符的优先数高于栈顶运算符，则进栈
5. 否则，退出栈顶运算符发送给后缀式
6. `(` 对它之前后的运算符起隔离作用，直接进栈
7. `)` 可视为自相应左括弧开始的表达式的结束符，将栈中自 `(` 起之上的运算符全部出栈

## Hanoi 塔
[4个圆盘的Hanoi塔，总的移动次数为(   )](https://www.nowcoder.com/questionTerminal/00a6dbdb815c49079022518c63b7d24b)
- N 个圆盘的移动次数为 2<sup>n</sup> - 1

## N 个数据的入栈序列对应的出栈序列种类数
[若序列进栈顺序为a,b,c,d,e，存在____种出栈序列](https://www.nowcoder.com/questionTerminal/2257e8d9d90a41959147dee462ae5a56)

# 队列的应用
## 图的广度优先搜索遍历
## 计算机主机与外存不匹配
## 二项式系数
- 一维数组实现 
```cpp

for (int i = 0; i < n; i++)
{
	int a[0] = a[i] = 1;
	for (int k = i - 1; k >= 1; k++)
		a[k] = a[k] + a[k - 1];
	for (int k = 0; k <= i; k++)
		prinf("%d", a[k]);
	printf("\n");
}
```

- 二维数组实现
	- 每行的第一个元素和对角线元素均为 1：a[i][0] = 1，a[i][i] = 1
	- 每行的 `非 1` 按**正序**求解，列下标 `m` 为 m = 1, 2，...，n - 2，n - 1：`a[i][m] = a[i - 1][m-1] + a[i - 1][m]`

```cpp

for (int i = 0; i < n; i++)
{
	int a[i][0] = a[i][i] = 1;
	for (int k = 1; k <= I - 1; k++)
		a[I][k] = a[I - 1][k] + a[I - 1][k - 1];
	for (int k = 0; k <= i; k++)
		prinf("%d", a[I][k]);
	printf("\n");
}
```
- 循环队列实现 
	- 在循环队列中依次存放第 i - 1 行上的元素，然后逐个出队并打印，同时生成第 i 行上的元素并入队

```cpp

InitQueue(Q);
EnQueue(Q,0);  
EnQueue(Q,1); 
EnQueue(Q,1); 

for(int m = 2; m <= n; m++)              //n为(a+b)n的指数
{   
     EnQueue(Q,0);
     do{ 
		 int x = DeQueue(Q);
		 int y = getHead(Q);
		 EnQueue(Q, x + y);
		 
     }while(y != 0);  //求解m次方的二项式系数
	
     .....            //输出二项式系数
}
```

[杨辉三角](https://blog.51cto.com/u_15672212/5381696)
	
## 划分无冲突子集
- 将集合 A 划分成 k 个互不相交的子集 A1，A2，…，Ak（k≤n），使同一子集中的元素均无冲突关系，并要求划分的子集数目尽可能地少
- 利用**过筛**的方法来解决划分子集问题。从第一个元素考虑起，凡不和第一个元素发生冲突的元素都可以和它分在同一子集中，然后再**过筛**出一批互不冲突的元素为第二个子集，依次类推，直至所有元素都进入某个子集为止
### 运动会赛事安排
- 用 `队列` 保存待选项目编号，用一维数组 `clash` 保存待选项目编号与已入选子集项目的冲突情况
- 排在队头的项目编号 i 是当前的待选项目，能否入选由 `clash[i]` 决定
	- 每次新开辟一组 (子集) 时，`clash` 数组各分量的值均为 `0`，当序号为 `i` 的元素入组时，将和该元素发生冲突的信息记入 `clash` 数组
	- 值为 0 表示无冲突，i 出队并加入子集
	- 值不为 0 表示有冲突，i 出队并重新排队

- 当排在队头的项目编号小于刚加入子集的项目编号是，表示队列内的所有项目都被 `过筛` 一遍，一个子集已划分完成

# 简答题
## **顺序队的“假溢出”是怎样产生的？如何知道循环队列是空还是满？**
- 一般的一维数组队列的尾指针已经到了数组的上界，不能再有入队操作，但其实数组中还有空位置，这就叫“假溢出”。采用循环队列是解决假溢出的途径
- 解决队满队空的办法有三：	
	1. 设置一个布尔变量以区别队满还是队空
	2. 浪费一个元素的空间，用于区别队满还是队空
	3. 使用一个计数器记录队列中元素个数（即队列长度）

- 我们常采用法 2，即队头指针、队尾指针中有一个指向实元素，而另一个指向空闲元素。
- 判断循环队列队空标志是： f = rear	队满标志是： f = (r + 1) % N

## **说明线性表、栈与队的异同点**
- **相同点**：都是线性结构，都是逻辑结构的概念。都可以用顺序存储或链表存储；栈和队列是两种特殊的线性表，即受限的线性表，只是对插入、删除运算加以限制
-  **不同点**：
	1. 运算规则不同，线性表为随机存取，而栈是只允许在一端进行插入、删除运算，因而是后进先出表 LIFO；队列是只允许在一端进行插入、另一端进行删除运算，因而是先进先出表 FIFO
	2. 用途不同，堆栈用于子程调用和保护现场，队列用于多道作业处理、指令寄存及其他运算等等

# 判断题
## 栈和链表是两种不同的数据结构
- 错，栈是逻辑结构的概念，是特殊殊线性表，而链表是存储结构概念，二者不是同类项

